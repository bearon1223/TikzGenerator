package com.tikz.grid;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.GdxRuntimeException;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class ImportFromTikz {
    /**
     * Converts Tikz code generated by this program to a format the code can understand and draw.
     *
     * @param tik tikz code
     * @return Array of Tikz Points in Grid Interface Format
     * @throws GdxRuntimeException   Throws Malformed Vector
     * @throws NullPointerException  Parsing Float for circles failed
     * @throws NumberFormatException Parsing Float for circles failed
     * @throws IllegalDrawType       Unknown Draw Code
     */
    public static Array<TikTypeStruct> FromTikToPoints(String tik) throws GdxRuntimeException, NullPointerException, NumberFormatException, IllegalDrawType {
        Array<TikTypeStruct> points = new Array<>();
        String[] commands = tik.split("\\n+");
        for (String command : commands) {
            command = command.replaceAll("\\s*\\\\draw\\s*", "");
            boolean isDashed = command.contains("dashed");
            boolean frontArrow = command.contains(">");
            boolean backArrow = command.contains("<");
            command = command.replaceAll("\\[(.*?)]", "").replaceAll(";", "");
            if (command.contains("node at")) {
                String regex = "\\(([^)]+)\\)\\s*\\{((?:\\$[^$]+\\$|[^{}])+)}";
                Pattern pattern = Pattern.compile(regex);
                Matcher matcher = pattern.matcher(command);
                if (matcher.find()) {
                    String vector = matcher.group(1);
                    vector = vector.replaceAll(",\\s*", ", ").trim();
                    Vector2 loc = new Vector2().fromString("(" + vector + ")");
                    String content = matcher.group(2);
                    points.add(new TikTypeStruct(loc, DrawType.TEXT, content));
                }
            } else if (command.contains("circle")) {
                // (a, b) circle(2.0cm);
                String regex = "\\(([^)]+)\\)\\s*circle\\s*\\(([^}]+)cm\\)";
                Pattern pattern = Pattern.compile(regex);
                Matcher matcher = pattern.matcher(command);
                if (matcher.find()) {
                    String vector = matcher.group(1);
                    vector = vector.replaceAll(",\\s*", ", ").trim();
                    Vector2 loc = new Vector2().fromString("(" + vector + ")");
                    float radius = Float.parseFloat(matcher.group(2));
                    TikTypeStruct tikType = new TikTypeStruct(loc, loc.cpy().add(radius, 0), DrawType.CIRCLE);
                    tikType.dashed = isDashed;
                    points.add(tikType);
                }
            } else if (command.contains("arc")) {
                throw new IllegalDrawType("Arcs are unable to be rendered as they are unpredictable: " + command);
            } else {
                String[] vectors = command.split("\\s*--\\s*");
                for (int i = 0; i < vectors.length; i++) {
                    vectors[i] = vectors[i].replaceAll(",\\s*", ", ").trim();
                }
                if (vectors.length == 2) {
                    Vector2 start = new Vector2().fromString(vectors[0]);
                    Vector2 end = new Vector2().fromString(vectors[1]);
                    TikTypeStruct tikType = new TikTypeStruct(start, end, DrawType.LINE);
                    tikType.dashed = isDashed;
                    tikType.frontArrow = frontArrow;
                    tikType.backArrow = backArrow;
                    points.add(tikType);
                } else if (vectors.length > 2) {
                    Array<Vector2> vector2Array = new Array<>();
                    for (String v : vectors) {
                        v = v.trim();
                        vector2Array.add(new Vector2().fromString(v));
                    }
                    TikTypeStruct tikType = new TikTypeStruct(vector2Array, DrawType.MULTI_LINE);
                    tikType.dashed = isDashed;
                    tikType.frontArrow = frontArrow;
                    tikType.backArrow = backArrow;
                    points.add(tikType);
                }
            }
        }
        return points;
    }

    /**
     * Converts a list of vectors into a polygon usable by this program
     *
     * @param vectorInput List of vectors
     * @param scale       How much to scale the output by
     * @param rotationDeg how much to rotate by in the clockwise direction
     * @return Array of Tikz Points in Grid Interface Format
     * @throws GdxRuntimeException   Throws Malformed Vector
     * @throws NullPointerException  Parsing Float for vectors failed
     * @throws NumberFormatException Parsing Float for vectors failed
     * @throws IllegalDrawType       Unknown Draw Code
     */
    public static TikTypeStruct FromVectorsToPoints(String vectorInput, float scale, float rotationDeg) throws GdxRuntimeException, NullPointerException, NumberFormatException, IllegalDrawType {
        Array<Vector2> vectors = new Array<>();
        String[] vectorStrings = vectorInput.replace("(", "").replace(")", "").split("\\n+");
        for (String v : vectorStrings) {
            if (v.isBlank()) continue;
            v = v.trim();
            // Split the numbers into two at the whitespace
            String[] splitVectorString;
            if (v.contains(",")) {
                splitVectorString = v.split(",");
                for (int i = 0; i < splitVectorString.length; i++) {
                    splitVectorString[i] = splitVectorString[i].trim();
                }
            } else {
                splitVectorString = v.split("\\s+");
            }

            if (splitVectorString.length != 2) throw new GdxRuntimeException("Malformed Vector " + v);
            String stringVector = "(" + splitVectorString[0] + "," + splitVectorString[1] + ")";

            vectors.add(new Vector2().fromString(stringVector).scl(scale).rotateDeg(rotationDeg));
        }
        return new TikTypeStruct(vectors, DrawType.MULTI_LINE);
    }
}
